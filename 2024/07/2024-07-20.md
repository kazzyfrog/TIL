---
date created: 2024-07-20, 01:31
date modified: 2024-07-21, 01:57
---

# Facade パターンで明確な設計パターンを意識する

## やったこと

- MDX・記事の操作に関するロジックを全てリファクタリングした！
- ファサードパターン（React でいうカスタムフック）についてのリサーチした
- ブログカードを、shadcn/ui ベースに変更した

## TL DR;

ポイントは、:

- コンポーネント関数は自身の責務 (レンダリング) に集中する。
- 内部の処理は必要に応じて細かく関数化する（単一責任）
- コンポーネントから直接末端の関数を順に呼んでいくのではなく、コンポーネントが必要とすることをまとめて処理する custom hook を意味ごとに作成しておき、コンポーネントからはそれを呼ぶようにする（Facade パターン）
- Next.js では、サーバーサイドではフックスが使えないので、どのように定義すべきかは、今後の課題。。！

参考

- https://www.creationline.com/tech-blog/58015
- https://zenn.dev/nekoniki/articles/d69efafa67faf67d202e

## ロジックはコンポーネント関数の外に書こう

理想的なコンポーネントには、少数の関数 (hook を含む) 呼び出しがあり、残りは DOM のレンダリングのみになっているはずです。

コンポーネント関数は自身の責務 (レンダリング) に集中し、それ以外の些末な処理は別の関数に任せるようにするのです。

このようなコンポーネントは「必要なデータを取得してそれを表示する」といったように、とても単純で分かりやすい作りになります。

オブジェクト指向の「単一責任の原則」に似ていますね。

## 意味のある単位で custom hook としてまとよう

例えば、コンポーネントで外部 API からデータを取得して、その結果を加工して表示するような場合を考えてみましょう。そのような場合には、それを全て行う custom hook を作成して呼び出すようにします。

内部の処理は必要に応じて細かく関数化していきますが、コンポーネントから直接末端の関数を順に呼んでいくのではなく、コンポーネントが必要とすることをまとめて処理する custom hook を意味ごとに作成しておき、コンポーネントからはそれを呼ぶようにするのです。

これによってコンポーネントが単純化され、hook や各関数の再利用性・テスタビリティが上がることになります。

デザインパターンで言うと「Facade パターン」ですね。

## 上記について AI に聞いた

### 設計パターンについて

上記のような関数の設計パターンや概念には一般的に使われる名称があります。
単体の関数とまとめる関数について、以下のような用語が使われることがあります：

1. 単体の関数:

   - 「プリミティブ関数」(Primitive Functions)
   - 「基本関数」(Basic Functions)
   - 「ユーティリティ関数」(Utility Functions)
   - 「原子的関数」(Atomic Functions)

2. まとめる関数:
   - 「ファサード」(Facade)
   - 「コンポジット関数」(Composite Functions)
   - 「高レベル関数」(High-Level Functions)
   - 「オーケストレーター」(Orchestrator)
   - 「アグリゲーター」(Aggregator)

特に、「ファサードパターン」(Facade Pattern) は、複雑なサブシステムに対してシンプルなインターフェースを提供するデザインパターンとして知られており、まさにこの「まとめる関数」の概念に合致します。

ソフトウェア設計の文脈では：

- 単体の関数は「低レベルの抽象化」(Low-Level Abstraction) と呼ばれることがあります。
- まとめる関数は「高レベルの抽象化」(High-Level Abstraction) と呼ばれることがあります。

また、関数型プログラミングの文脈では：

- 単体の関数は「純粋関数」(Pure Functions) や「副作用のない関数」(Side-Effect Free Functions) と呼ばれることがあります。
- まとめる関数は「合成関数」(Composed Functions) や「高階関数」(Higher-Order Functions) と呼ばれることがあります。

これらの用語は文脈や使用される環境によって異なる場合がありますが、概念を説明する際に役立つ共通の語彙として使用されています。ユニットテストとインテグレーションテストの関係性と同様に、これらの関数の設計も、小さな単位の機能と、それらを組み合わせたより大きな機能という階層構造を反映しています。

### ベストプラクティスについて

ご質問ありがとうございます。これは興味深い点で、プロジェクトの構造や要件によって最適な方法が変わる可能性がありますが、一般的には単体の関数をまとめる関数を作成し、それをページで使用することは良い実践であると言えます。以下に理由と考慮点を説明します。

まとめる関数を使用する利点：

1. テスタビリティの向上：
   おっしゃる通り、まとめる関数を使用することでテストが容易になります。単体テストと統合テストの両方が書きやすくなります。

2. 関心の分離：
   ページコンポーネントはデータの取得や処理のロジックから分離され、表示に集中できます。

3. 再利用性：
   まとめる関数は他のページやコンポーネントでも簡単に再利用できます。

4. 保守性：
   ロジックの変更が必要な場合、まとめる関数だけを修正すれば良いので、保守が容易になります。

5. 抽象化：
   複雑なロジックを隠蔽し、ページコンポーネントをよりシンプルに保てます。

6. エラーハンドリング：
   まとめる関数内で一元的にエラーハンドリングができます。

考慮点：

1. オーバーエンジニアリング：
   非常に単純な操作の場合、まとめる関数を作成するのが過剰になる可能性があります。

2. パフォーマンス：
   まとめる関数が不要なデータも取得してしまう場合、パフォーマンスに影響を与える可能性があります。

3. 柔軟性：
   まとめる関数が固定的すぎると、特殊なケースに対応しづらくなる可能性があります。

結論：
単体の関数をまとめる関数を作成し、ページ内でそのまとめる関数を使用することは、多くの場合においてベストプラクティスと言えます。特に：

- プロジェクトの規模が大きい
- ロジックが複雑
- 同じロジックを複数の場所で使用する
- テストの容易さを重視する

これらの条件に当てはまる場合は、まとめる関数を使用することをお勧めします。

ただし、非常にシンプルな操作や、ページ固有の特殊なロジックの場合は、直接単体の関数を呼び出すこともあります。

最終的には、コードの可読性、保守性、再利用性、そしてパフォーマンスのバランスを考慮して判断することが重要です。テストの容易さを重視されているのであれば、まとめる関数を使用する方針は良い選択だと思います。
