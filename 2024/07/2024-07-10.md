---
date created: 水曜日, 7月 10日 2024, 3:39:25 午後
date modified: 木曜日, 7月 11日 2024, 1:59:47 午前
---

# Next.js v14.2 で、ローカルコンテンツで読み込む

ローカルコンテンツをロードするには、fs や path などの Node.js モジュールを使用して、ファイルシステムから MDX ファイルを読み込みます。
これにより、ファイルパスに基づいて MDX コンテンツを動的にフェッチしてレンダリングできます。

## 1. node.js の fs モジュールについて:

fs モジュールは、Node.js のコアモジュールの 1 つで、ファイルシステムとのやり取りを可能にします。
ファイルの読み書き、ディレクトリの作成・削除、ファイル情報の取得などの操作ができます。

## 2. 代表的な `fs` モジュールの関数:

- `readFile()`: ファイルを非同期で読み込む
- `writeFile()`: ファイルに非同期で書き込む
- `readdir()`: ディレクトリ内のファイル一覧を非同期で取得
- `mkdir()`: ディレクトリを非同期で作成
- `unlink()`: ファイルを非同期で削除
- `stat()`: ファイルの情報を非同期で取得

## 3. readdirSync、readFileSync と readfile, readDir の違い:

- `readdirSync()` と `readFileSync()`: 同期版の関数。処理が完了するまでプログラムの実行をブロックします。
- `readdir()` と `readFile()`: 非同期版の関数。処理を開始し、完了時にコールバック関数を呼び出します。プログラムの実行をブロックしません。

## 4. readdirSync、readFileSync と readfile, readDir の使い分け:

- 同期版（Sync）:
  - 簡単なスクリプトや、順序が重要な処理
  - アプリケーションの初期化時など、ブロッキングが問題にならない場合
- 非同期版:
  - 大規模なアプリケーションやサーバーサイドの処理
  - パフォーマンスが重要な場合
  - 複数の操作を並行して行う必要がある場合

必要に応じて、同期的メソッドと非同期的メソッドを使い分けることが重要です。
非同期的な操作は、I/O 操作が多い場合や、パフォーマンスを重視する場合に推奨されます。

## 5. Next.js にて、ローカルディレクトリ内の md ファイルを静的生成するプロジェクトでのベストプラクティス:

Next.js の静的生成では、ビルド時にコンテンツを生成するため、同期版の関数を使用するのが一般的です。以下は、ベストプラクティスの例です：

```javascript
import fs from "fs";
import path from "path";
import matter from "gray-matter";

const postsDirectory = path.join(process.cwd(), "posts");

export function getSortedPostsData() {
  // ディレクトリ内のファイル名を取得
  const fileNames = fs.readdirSync(postsDirectory);
  const allPostsData = fileNames.map((fileName) => {
    // ファイル名から .md を削除してidとする
    const id = fileName.replace(/\.md$/, "");

    // マークダウンファイルを文字列として読み取る
    const fullPath = path.join(postsDirectory, fileName);
    const fileContents = fs.readFileSync(fullPath, "utf8");

    // gray-matterを使用してメタデータセクションを解析
    const matterResult = matter(fileContents);

    // データをidと組み合わせる
    return {
      id,
      ...matterResult.data,
    };
  });

  // 日付でソートする
  return allPostsData.sort((a, b) => {
    if (a.date < b.date) {
      return 1;
    } else {
      return -1;
    }
  });
}
```

このアプローチでは、`readdirSync()` と `readFileSync()` を使用してファイルシステムからデータを読み込み、静的生成に必要な情報を取得しています。これにより、ビルド時に全ての必要なデータを処理し、効率的に静的ページを生成できます。

この方法は、コンテンツの量が多すぎない場合に適しています。大量のコンテンツがある場合は、パフォーマンスを考慮して、増分的静的再生成（ISR）やサーバーサイドレンダリング（SSR）の使用を検討するとよいでしょう。

### メモ：同期版の関数を使用するのが好ましい５つの理由

静的生成において同期版の関数を使用するのが好ましい理由は、：

1. ビルド時の処理:
   Next.js の静的生成は主にビルド時に行われます。この時点では、リアルタイムのユーザーリクエストを処理しているわけではないため、処理をブロックすることによる問題が少ないです。
2. 簡潔なコード:
   同期版の関数を使うと、コードがより直線的で理解しやすくなります。非同期処理を使う場合、Promise chains や async/await の使用が必要となり、コードが複雑になる可能性があります。
3. エラーハンドリングの簡素化:
   同期処理では、try-catch ブロックを使用して簡単にエラーをキャッチできます。非同期処理では、エラーハンドリングがより複雑になる可能性があります。
4. 順序の保証:
   ファイルの読み込みや処理の順序が重要な場合、同期処理ではその順序を簡単に制御できます。
5. パフォーマンスの考慮:
   ビルド時の処理では、通常、同期処理と非同期処理のパフォーマンスの差はあまり大きくありません。むしろ、同期処理のほうがオーバーヘッドが少ない場合もあります。

ただし、以下の点に注意が必要です：

- 大規模プロジェクト:
  非常に多くのファイルを処理する必要がある大規模プロジェクトでは、非同期処理を検討する価値があります。
- ビルド時間:
  同期処理によってビルド時間が極端に長くなる場合は、非同期処理や他の最適化方法を検討すべきです。
- 外部リソースへのアクセス:
  ローカルファイルシステム以外（例：データベースや API）からデータを取得する場合は、非同期処理が適している可能性が高いです。

## 結論

結論として、Next.js の静的生成におけるローカルファイルの処理では、多くの場合、同期版の関数を使用することで、シンプルで理解しやすく、効率的なコードを書くことができます。
ただし、プロジェクトの規模や特性に応じて、適切なアプローチを選択することが重要です。

## 参考

- [node.js/fs](https://nodejs.org/api/fs.html)
- [jsPrimer](https://jsprimer.net/use-case/nodecli/read-file/)

## コメント

今日は、mdx-remote 調べた。だいたい中身わかった：

- 基本は、２つある。コンポーネントと関数。前者はクライアントサイドで動き、後者はサーバーサイド。next-mdx-remote は、関数とコンポーネント、serialize、<MDXRemote />を公開します。これら 2 つは意図的に独自のファイルに分離されています
- next-mdx-remote/rsc の場合は、compileMDX で JSX を直接吐かせるか、`<MDXRemote>` コンポーネントに Markdown / MDX を食わせるか、２つの方法を選べるよう （おそらくどちらでも出力に差はない）

加えて、

- 上記、fs の使い分けもわかった
- あとディレクトリに、`_posts` にすることも！

１日コードとドキュメントを眺めていたので目が疲れた！
でも MD を JSX に変換している流れは理解した！
